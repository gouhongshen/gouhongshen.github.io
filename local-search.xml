<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Percolator 随笔</title>
    <link href="/2022/06/18/Percolator-%E9%9A%8F%E7%AC%94/"/>
    <url>/2022/06/18/Percolator-%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记 CMU-15445 课程所得</title>
    <link href="/2022/06/16/%E8%AE%B0-CMU-15445-%E8%AF%BE%E7%A8%8B%E6%89%80%E5%BE%97/"/>
    <url>/2022/06/16/%E8%AE%B0-CMU-15445-%E8%AF%BE%E7%A8%8B%E6%89%80%E5%BE%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU-15445</tag>
      
      <tag>关系型数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyKV Snapshot 流程探秘</title>
    <link href="/2022/06/16/TinyKV-Snapshot-%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/06/16/TinyKV-Snapshot-%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写 TinyKV 时，有一个部分很难理解，那就 Snapshot 的收发过程。<br>为了防止内存中的日志条目无限扩张，Raft 会定时&#x2F;定量清理日志（如已经提交了的日志），一些节点可能由于是新加入或者网络等原因，其想要复制的日志已经被 leader 清理出内存了，此时，leader 会给该节点发送一份 Snapshot 使其快速跟上。在实现代码时，Raft 只是使用 Snapshot 的元数据来更新了一些状态，并没有涉及的日志的追加等操作，深感疑惑。而且，Snapshot 一般很大，虽然可以作为普通消息处理，但可能会阻塞正常的流程，所以对它的收发过程也很感兴趣。为了搞清楚这些问题，追踪代码调用，总算是搞清楚了。下面分为 Snapshot 的发送、接收、处理几个方面解密。</p><h2 id="Snapshot-流程总览"><a href="#Snapshot-流程总览" class="headerlink" title="Snapshot 流程总览"></a>Snapshot 流程总览</h2><p>这里先给出 snapshot 各个部分的流程示意图，下面会对各个部分详细分析<br><img src="/img/tinykv_snapshot/tinykv_arch.png" alt="TinyKV 的整体架构（代码层面）"><br><img src="/img/tinykv_snapshot/fig_for_create.png" alt="snapshot 创建流程"><br><img src="/img/tinykv_snapshot/fig_for_send.png" alt="snapshot 发送流程"><br><img src="/img/tinykv_snapshot/fig_for_recv.png" alt="snapshot 接收流程"><br><img src="/img/tinykv_snapshot/fig_for_apply.png" alt="snapshot 应用流程"></p><h2 id="Part-1：Snapshot-的创建"><a href="#Part-1：Snapshot-的创建" class="headerlink" title="Part 1：Snapshot 的创建"></a>Part 1：Snapshot 的创建</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> sendAppend(to <span class="hljs-type">uint64</span>) &#123;<br>    term, err := r.RaftLog.Term(r.Prs[to].Next - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// the peer left too far behind  (or newly join), </span><br>        <span class="hljs-comment">// send it a snapshot to catch-up</span><br>        r.trySendSnapshot(to)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// something else</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> trySendSnapshot(to <span class="hljs-type">uint64</span>) &#123;<br>    snapshot, err := r.RaftLog.storage.snapshot()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    r.msgs = <span class="hljs-built_in">append</span>(r.msgs, SnapshotMessage&#123;...&#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第一个函数表明了 Raft 发送 Snapshot 的时机，第二个函数表明了 Snapshot 来自 storage。</p><blockquote><p>这个 storage 在 2A部分和之后的部分是不一样的，值得分析下。在 2A 中，storage 接口由 MemoryStorage 实现，这货存在于内存中，文档中写着，放入 storage 的日志是持久化的（stabled），当时很不理解，因为它也是存在内存中的啊，做到后面才发现，这里的 MemoryStorage 主要起着测试的作用，你只需要闭只眼假装它真的持久化了就行。而在后面的部分，storage 接口由 badger.DB（engines.Raft）实现，是实打实的写入磁盘。</p></blockquote><p>那么，调用 storage.snapshot() 实际做了什么？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ps *PeerStorage)</span></span> Snapshot() (eraftpb.Snapshot, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> snapshot eraftpb.Snapshot<br>    <span class="hljs-keyword">if</span> snapshot_is_generating &#123;<br>        snapshot &lt;- ps.snapState.Receiver<br>        <span class="hljs-keyword">return</span> snapshot, <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// something else</span><br><br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *eraftpb.Snapshot, <span class="hljs-number">1</span>)<br>ps.snapState = snap.SnapState&#123;<br>StateType: snap.SnapState_Generating,<br>Receiver:  ch,<br>&#125;<br><span class="hljs-comment">// schedule snapshot generate task</span><br>ps.regionSched &lt;- &amp;runner.RegionTaskGen&#123;<br>RegionId: ps.region.GetId(),<br>Notifier: ch,<br>&#125;<br><br>    <span class="hljs-keyword">return</span> snapshot, raft.ErrSnapshotTemporarilyUnavailable<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码很清楚，如果当前正在生成 snapshot，那么就等待它生成完成并返回，否则，就创建一个 RegionTaskGen 任务发送给 regionSched 通道，并返回暂时不可用错误。那么是谁在接收该任务呢？</p><p>上面说到 Raft 调用生成 snapshot 的接口，该接口的实现（PeerStorage）会创建一个 RegionTaskGen 任务发送给 regionSched 通道。该通道的消费者实际上是 regionWorker：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Worker)</span></span> Start(handler TaskHandler) &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>Task := &lt;-w.receiver<br><span class="hljs-keyword">if</span> _, ok := Task.(TaskStop); ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>handler.Handle(Task)<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *regionTaskHandler)</span></span> Handle(t worker.Task) &#123;<br><span class="hljs-keyword">switch</span> t.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *RegionTaskGen:<br>task := t.(*RegionTaskGen)<br><span class="hljs-comment">// It is safe for now to handle generating and applying snapshot concurrently,</span><br><span class="hljs-comment">// but it may not when merge is implemented.</span><br>r.ctx.handleGen(task.RegionId, task.Notifier)<br><span class="hljs-keyword">case</span> *RegionTaskApply:<br>task := t.(*RegionTaskApply)<br>        <span class="hljs-comment">// apply received snapshot</span><br>r.ctx.handleApply(task.RegionId, task.Notifier, task.StartKey, task.EndKey, task.SnapMeta)<br><span class="hljs-keyword">case</span> *RegionTaskDestroy:<br>task := t.(*RegionTaskDestroy)<br>r.ctx.cleanUpRange(task.RegionId, task.StartKey, task.EndKey)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>regionWorker 创建一个协程，处理接收到的各种任务。其中有两种任务是本文需要关注的：<br>1）RegionTaskGen（生成 snapshot）<br>2）RegionTaskApply（应用从其他 peer 接收来的 snapshot）</p><p>继续看 RegionTaskGen 任务是如何执行的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(snapCtx *snapContext)</span></span> handleGen(...) &#123;<br>snap, err := doSnapshot(...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>notifier &lt;- <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// notify task done to task creator</span><br>notifier &lt;- snap<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSnapshot</span><span class="hljs-params">(...)</span></span> (*eraftpb.Snapshot, <span class="hljs-type">error</span>) &#123;<br>log.Debugf(<span class="hljs-string">&quot;begin to generate a snapshot. [regionId: %d]&quot;</span>, regionId)<br>    <span class="hljs-comment">// kvDB !!!</span><br>txn := engines.Kv.NewTransaction(<span class="hljs-literal">false</span>)<br>    <span class="hljs-comment">//...</span><br>err = s.Build(txn, ...)<br>    <span class="hljs-comment">//...</span><br><span class="hljs-keyword">return</span> snapshot, err<br>&#125;<br></code></pre></td></tr></table></figure><p>该 Build() 函数最终会调用 snapBuilder.build()，函数会扫描 PeerStorage.kvDB 的数据，创建一份快照：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *snapBuilder)</span></span> build() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">defer</span> b.txn.Discard()<br>startKey, endKey := b.region.StartKey, b.region.EndKey<br><br>    <span class="hljs-comment">// all data will store in b.cfFiles</span><br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> b.cfFiles &#123;<br>cf := file.CF<br>sstWriter := file.SstWriter<br><br>it := engine_util.NewCFIterator(cf, b.txn)<br><span class="hljs-keyword">for</span> it.Seek(startKey); it.Valid(); it.Next() &#123;<br>item := it.Item()<br>key := item.Key()<br><br>value, err := item.Value()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>cfKey := engine_util.KeyWithCF(cf, key)<br>            <span class="hljs-comment">// store data</span><br><span class="hljs-keyword">if</span> err := sstWriter.Add(cfKey, y.ValueStruct&#123;<br>Value: value,<br>&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>it.Close()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>自此，Snapshot 的创建过程分析完成</p><h2 id="Part-2：Snapshot-的发送"><a href="#Part-2：Snapshot-的发送" class="headerlink" title="Part 2：Snapshot 的发送"></a>Part 2：Snapshot 的发送</h2><p>当 sendAppend() 函数获取到创建的 snapshot 后，会将其封装在 pb.MessageType_MsgSnapshot 消息中，等待 RaftStorage 层调用 rawNode.Ready()：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *peerMsgHandler)</span></span> HandleRaftReady() &#123;<br><span class="hljs-comment">// Your Code Here (2B).</span><br>rd := d.RaftGroup.Ready()<br>d.sendMessageToPeers(rd.Messages)<br>    <span class="hljs-comment">// ...</span><br>d.RaftGroup.Advance(rd)<br>&#125;<br></code></pre></td></tr></table></figure><p>sendMessageToPeers() 最终会调用 WirteData() 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *ServerTransport)</span></span> WriteData(...) &#123;<br><span class="hljs-keyword">if</span> msg.GetMessage().GetSnapshot() != <span class="hljs-literal">nil</span> &#123;<br>t.SendSnapshotSock(addr, msg)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> err := t.raftClient.Send(storeID, addr, msg); err != <span class="hljs-literal">nil</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;send raft msg err. err: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在 WriteData 中对 snapshot 消息做了一个拦截，采用另外的方式单独处理：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *ServerTransport)</span></span> SendSnapshotSock(...) &#123;<br>t.snapScheduler &lt;- &amp;sendSnapTask&#123;<br>addr:     addr,<br>msg:      msg,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这下明白了，由于 snapshot 比较大，会采用分块传输，对它的发送操作与普通的消息分开，由 sendSnapTask 异步完成。<br>继续探寻该任务是如何被执行的，该任务被 snapWorker 接收，并调用 Handle() 处理：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *snapRunner)</span></span> Handle(t worker.Task) &#123;<br><span class="hljs-keyword">switch</span> t.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *sendSnapTask:<br>r.send(t.(*sendSnapTask))<br><span class="hljs-keyword">case</span> *recvSnapTask:<br>r.recv(t.(*recvSnapTask))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *snapRunner)</span></span> send(t *sendSnapTask) &#123;<br>t.callback(r.sendSnap(t.addr, t.msg))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *snapRunner)</span></span> sendSnap(...) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, snapChunkLen) <span class="hljs-comment">// snapChunkLen = 1024 * 1024</span><br><span class="hljs-keyword">for</span> remain := snap.TotalSize(); remain &gt; <span class="hljs-number">0</span>; remain -= <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(buf)) &#123;<br>_, err := io.ReadFull(snap, buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;failed to read snapshot chunk: %v&quot;</span>, err)<br>&#125;<br>err = stream.Send(&amp;raft_serverpb.SnapshotChunk&#123;Data: buf&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最终 snapshot 以 snapChunkLen 为单位分块发送出去的，后面的事情就是 gRPC 的工作了，探秘自此结束。 </p><h2 id="Part-3：Snapshot-的接收"><a href="#Part-3：Snapshot-的接收" class="headerlink" title="Part 3：Snapshot 的接收"></a>Part 3：Snapshot 的接收</h2><p>当使用 gRPC 发送 snapshot 时，对应 peer 也就进入了接收流程。上面提到的 snapWorker 也会处理接收操作，这里不再赘述。当所有的 snapshot 分块都接受完成后，就会给 raftWorker 监听的管道发送消息，最后调用 rawNode.Step() 让 raft 调用 handleSnapshot() 处理。 </p><h2 id="Part-4：应用来自其他-Peer-的-Snapshot"><a href="#Part-4：应用来自其他-Peer-的-Snapshot" class="headerlink" title="Part 4：应用来自其他 Peer 的 Snapshot"></a>Part 4：应用来自其他 Peer 的 Snapshot</h2><p>handleSnapshot() 接收到 snapshot 后只是更新了一些元数据，并将 snapshot 赋值给 pendingSnapshot，等待上层调用 Ready() 获取 pendingSnapshot：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *peerMsgHandler)</span></span> HandleRaftReady() &#123;<br><span class="hljs-comment">// Your Code Here (2B).</span><br>rd := d.RaftGroup.Ready()<br>applySnapResult, _ := d.peerStorage.SaveReadyState(&amp;rd)<br><span class="hljs-comment">//...</span><br>d.RaftGroup.Advance(rd)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ps *PeerStorage)</span></span> SaveReadyState(ready *raft.Ready) &#123;<br><span class="hljs-comment">// Your Code Here (2B/2C).</span><br>applySnapResult, err := ps.ApplySnapshot(&amp;ready.Snapshot, ...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ps *PeerStorage)</span></span> ApplySnapshot(snapshot *eraftpb.Snapshot, ...) &#123;<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-comment">// send runner.RegionTaskApply task to region worker through </span><br>    <span class="hljs-comment">// PeerStorage.regionSched and</span><br><span class="hljs-comment">// wait until region worker finishes</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>)<br>ps.regionSched &lt;- &amp;runner.RegionTaskApply&#123;<br>RegionId: snapData.Region.GetId(),<br>Notifier: ch,<br>SnapMeta: snapshot.Metadata,<br>StartKey: snapData.Region.StartKey,<br>EndKey:   snapData.Region.EndKey,<br>&#125;<br><br><span class="hljs-comment">// waiting</span><br>&lt;-ch<br>    <span class="hljs-keyword">return</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码很明显了，上层获取到 Ready.Snapshot 后，会创建 RegionTaskApply 任务通过 regionSched 通道发送给 RegionWorker -&gt; handle() -&gt; handleApply() 处理：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *regionTaskHandler)</span></span> Handle(t worker.Task) &#123;<br><span class="hljs-keyword">switch</span> t.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *RegionTaskGen:<br>task := t.(*RegionTaskGen)<br><span class="hljs-comment">// It is safe for now to handle generating and applying snapshot concurrently,</span><br><span class="hljs-comment">// but it may not when merge is implemented.</span><br>r.ctx.handleGen(task.RegionId, task.Notifier)<br><span class="hljs-keyword">case</span> *RegionTaskApply:<br>task := t.(*RegionTaskApply)<br>r.ctx.handleApply(task.RegionId, task.Notifier, task.StartKey, task.EndKey, task.SnapMeta)<br><span class="hljs-keyword">case</span> *RegionTaskDestroy:<br>task := t.(*RegionTaskDestroy)<br>r.ctx.cleanUpRange(task.RegionId, task.StartKey, task.EndKey)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(snapCtx *snapContext)</span></span> handleApply(...) &#123;<br>err := snapCtx.applySnap(regionId, startKey, endKey, snapMeta)<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(snapCtx *snapContext)</span></span> applySnap(...) &#123;<br>applyOptions := snap.NewApplyOptions(snapCtx.engines.Kv, &amp;metapb.Region&#123;<br>Id:       regionId,<br>StartKey: startKey,<br>EndKey:   endKey,<br>&#125;)<br><span class="hljs-keyword">if</span> err := snapshot.Apply(*applyOptions); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，上面一步步调用，最后调用 snapshot.Apply()，注意这里传入的是 badger.kvDB。<br>snapshot.Apply() 和上面提到的 snapshot 创建过程的 snapBuilder.build() 执行的是相反的步骤，即，将 snapshot 中的内容写入到磁盘:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Snap)</span></span> Apply(opts ApplyOptions) <span class="hljs-type">error</span> &#123;<br>externalFiles := <span class="hljs-built_in">make</span>([]*os.File, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s.CFFiles))<br><span class="hljs-keyword">for</span> _, cfFile := <span class="hljs-keyword">range</span> s.CFFiles &#123;<br>file, err := os.Open(cfFile.Path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;open ingest file %s failed: %s&quot;</span>, cfFile.Path, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br>externalFiles = <span class="hljs-built_in">append</span>(externalFiles, file)<br>&#125;<br>    <span class="hljs-comment">// write to DB</span><br>n, err := opts.DB.IngestExternalFiles(externalFiles)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>snapshot 的应用分析自此结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，可以得到以下信息：</p><ol><li>snapshot 的创建、发送、接收和处理都与 Raft 无关，它无需关系具体数据（除了元数据）。</li><li>snapshot 的发送和接收都采取了单独的 RPC 异步处理。</li><li>生成 snapshot 需要从 kvDB 中读取数据，然后返回给 Raft，最后通过 Ready 交给上层发送。</li><li>snapshot 接收后，需要先交给 Raft 更新一些元数据，然后通过 Ready 交给上层写到 kvDB 中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TinyKV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft 算法杂记</title>
    <link href="/2022/06/14/raft-%E6%9D%82%E8%AE%B0/"/>
    <url>/2022/06/14/raft-%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间学习了 CMU-15445 的课程，也写完了 project，了解了数据库内核的基本知识。这段时间在做 TinyKV，刚好看了 raft，细节很多，所以来总结下。</p><p>关于 raft 网上有很多资料：<br><a href="https://raft.github.io/raft.pdf">raft 论文</a><br><a href="https://tanxinyu.work/raft/">raft 博客</a><br><a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd raft 实现</a></p><p>所以，这里并不是对 raft 算法本身的细节记录，而是自己阅读、实现时的一些疑问和解答。</p><h2 id="Q1：raft算法解决了什么问题？"><a href="#Q1：raft算法解决了什么问题？" class="headerlink" title="Q1：raft算法解决了什么问题？"></a>Q1：raft算法解决了什么问题？</h2><p>raft 是一个分布式共识协议（算法），其主要作用是让集群中的节点对某件事情达成一致，如客户端发起更新请求，为了保证多个节点的数据状态一致，就需要让该更新请求在所有节点上都应用成功，否则更新请求失败。raft 算法可以看作一个黑匣子，当某个节点接收到客户端的请求后，首先将该请求交给 raft 模块，由 raft 模块负责节点间的协商，最后将结果返回给节点，节点再反馈客户端。如下图的复制状态机所示。</p><p><img src="/img/raft/rsm.png"></p><p>图中的 consensus module 就相当于 raft 黑匣子，state machine 可以理解为 kv 键值数据库。还需要注意两点：1）日志记录和协商同步进行；2）图中是分层的，表示多个客户端和集群节点。</p><h2 id="Q2：在实际实现中，整个分布式系统的流程如何？"><a href="#Q2：在实际实现中，整个分布式系统的流程如何？" class="headerlink" title="Q2：在实际实现中，整个分布式系统的流程如何？"></a>Q2：在实际实现中，整个分布式系统的流程如何？</h2><p>这个问题实际是关于</p><ol><li>集群节点如何与客户端交互？</li><li>集群节点如何与 raft 模块交互？</li><li>raft 模块如何与其他 raft 模块交互？</li></ol><p>要解答这些问题，需要借助现有的成熟的工业系统，比如 etcd、tikv 等等，因为比较熟悉 TinyKV，所以以它为例。</p><p>TinyKV 的设计参照了 etcd，将 raft 模块设计成独立的部分，raft 需要的网络、存储服务由上层（非 raft)提供，比较具有灵活性，具体流程如下：</p><ol><li>客户端向节点发送请求（put&#x2F;get&#x2F;delete…)</li><li>节点准备 WAL(write-ahead-log)</li><li>节点将请求封装成 entry 发送给 raft 模块</li><li>节点获取 raft 算法的输出，主要有一下部分：<br> 1）raft 需要存储的日志记录（unstable entry 和一些 raft 自身状态信息）<br> 2）committed entry（已经在大多数节点间达成一致的 entry）<br> 3）messages，需要发往其他 raft 模块的消息</li><li>节点获取到 raft 的输出后，按其类型做一些操作，对于 unstable entry 和状态信息，执行持久化操作；对于 committed entry，它们已处于安全状态，可以应用于数据库了，并且可以就这些 entry 中的请求向客户端反馈成功；对于messages，将其发送到对应的 raft 模块。完成以上操作后，通知 raft 模块。</li></ol><p><em>为什么 raft 会存储 unstable entry 和状态信息，比如 peers，是为了从崩溃中恢复</em></p><p><strong>总结一下</strong>，raft 模块被独立实现，其算法输入来自上层（这里的输入可能是客户端请求，也可能是其他 raft 模块的消息），其算法输出由上层负责处理（存储、发送等），从这里也能知道，raft 根本不关心 entry 中的具体请求，那是上层逻辑的责任，它只需要采取办法能够唯一标识一条 entry 即可（Term、Index）。</p><h2 id="Q3：当网络分区发生时，raft算法有什么表现？"><a href="#Q3：当网络分区发生时，raft算法有什么表现？" class="headerlink" title="Q3：当网络分区发生时，raft算法有什么表现？"></a>Q3：当网络分区发生时，raft算法有什么表现？</h2><p>该问题比较大，需要分类讨论：</p><ol><li>单个 follower 节点被隔离，恢复后，会发生什么？</li><li>网络分区发生时，leader 处在少数部分，恢复后会发生什么？</li><li>网络分区发生时，leader 处在多数部分，恢复后会发生什么？</li></ol><p><font color=red>对于第一个问题</font>，先看被隔离节点的表现：因为是 follower，它只能被动应答，在一段时间内没有异常发生。等到 election_timeout 后，它自增 Term，发起选举请求，由于网络问题，其他节点接收不到该请求，然后再次等到 election_timeout，再次自增 Term，发起选举请求……它重复该操作，直到从隔离中恢复。</p><p>该节点（记为 A）从隔离中恢复后，可能会先收到 leader 发来的 AppenEntriesRPC 或者 HeartBeatRPC，但 leader.Term &lt; A.Term，根据算法，这些 RPC 对 A 没有影响，但 leader 会受到影响，leader 会转变为 follower。集群中先超时的节点会率先发起选举请求，由于存在选举限制：<strong>要获取到大多数的选票，就必须具有最新的日志记录（通过比较最后一份日志的 Term 和 Index 判断）</strong>，这样的选举可能会持续多次，但无论如何节点 A 都不可能当选 leader，因为它被隔离，没有后面新追加的日志。也就是说，节点 A 的重新加入造成了系统不必要的抖动，其原因在于，节点 A 在隔离期间盲目地自增 Term。</p><p>etcd 是如何解决该问题的呢？采用 preVote 机制，即当一个节点超时后，它并不急于自增 Term，而是先发起选举请求，如果能获取到大多数的选票，再自增 Term 重新发起选举。</p><br><font color=red>对于第二个问题</font>，leader 处在少数节点分区部分，根据 raft 要求，一条 entry 能被提交，该entry 至少需要被 N/2 + 1 个节点安全复制，因此上层交付的任务 proposal 都无法被提交，自然无法被应用到数据库和反馈客户端，客户端会出现请求超时。后面的客户端请求可能会被路由到另外一个节点，直到请求能够被正常执行。<p>当网络分区恢复后，该 leader 会接受来自新 leader 的 RPC 请求，转换成 follower，开始正常的日志复制。该种情况下，是否会出现第一个问题中的场景呢？是有可能的，比如四个节点，每个分区中存在两个节点，包含 leader 的分区不会触发新的选举，但另外一个分区会发起多次的选举（或预选举），<strong>这种情况下，整个系统瘫痪，无法对外服务</strong>。</p><br><font color=red>对于第三个问题</font>，这种情况相对较简单，系统可正常对外服务，少数分区可能存在多次选举，但分区恢复后，可以开始正常的日志复制，具体过程在前两个问题中已经提及。<h2 id="Q4：leader-commit日志之前崩溃了，会发生什么？"><a href="#Q4：leader-commit日志之前崩溃了，会发生什么？" class="headerlink" title="Q4：leader commit日志之前崩溃了，会发生什么？"></a>Q4：leader commit日志之前崩溃了，会发生什么？</h2><p>该问题在 raft 论文中有论述，是关于如何处理前任 leader 复制的日志。<strong>我当时的疑问是</strong>：leader 将最新的日志复制到了一部分节点后，或许是还未满足大多数原则，或许是 commit 之前就崩溃了，这些最新的日志会被怎么处理？</p><p>后来再次仔细阅读论文，发现并理解了更加细微的点。借助论文中对该问题的讨论部分的图示，再来复盘一下：</p><p><img src="/img/raft/Q4_1.png"></p><p>图中方块中的数字标识 Term，上方的数字标识 Index。</p><ol><li><p>(a)中，S1 为 Term2 的 leader，在将 Index&#x3D;2 的日志复制到 S2 后崩溃。</p></li><li><p>(b)中，S1 崩溃后，S5 在 Term3 当选 leader（根据选举限制，在最后一条日志中，S5 具有更大的 Term，所以能够当选）</p></li><li><p>(c)中，S5 崩溃，S1 在 Term4 当选 leader，并继续复制日志，此时它将 Index&#x3D;2 的日志成功复制到了大多数节点上，但还未提交。</p></li><li><p>(d1) 和 (d2) 描述两种情况：<br> 第一种是(d1)，以前任期复制的日志（未提交）被后面新的日志覆盖。客户端等待响应超时，会重新发起请求（我之前还在担心，这会不会造成数据丢失，太天真了）。对应的是 S1 再次崩溃，在 (c) 的局面下，S5 再次当选 leader（图中未画出新的任期，S5 可以获得 S2-4 的选票），由于复制日志以 leader 的日志为准，所以Index&#x3D;2的以前任期的日志会被 S5 的 Index&#x3D;2 的日志覆盖。</p><p> 第二种是(d2)，以前任期复制的日志可以被后面新的 leader 提交（属于被动提交，因为 raft 中，提交一条日志，就表示该条日志之前的所有日志都已被提交）。对应的是，S1 在崩溃之前将日志复制到了大多数节点上，此时 S5 已经不可能再当选，新的 leader 只能在 S1-3 之中。假设，S1 未崩溃，那么，S1 通过提交 Index&#x3D;3 的日志，之前的日志也就一起被动提交了；就算 S1 在提交之前崩溃了，新的 leader 通过提交当前任期的日志也能提交以前任期的所有日志。</p></li></ol><p><strong>从这里，应当认识到两点</strong>：<br>1）复制的日志可能会被覆盖，客户端会重试。<br>2）raft 算法中，leader 会强制要求其他节点的日志与自己一致，对安全性的考虑应该结合选举限制一起理解。</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式一致性协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客使用记录</title>
    <link href="/2022/06/13/Hexo%20%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/06/13/Hexo%20%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Record-1：文章内部图片死活加载不出来"><a href="#Record-1：文章内部图片死活加载不出来" class="headerlink" title="Record 1：文章内部图片死活加载不出来"></a>Record 1：文章内部图片死活加载不出来</h3><p>刚使用 fluid 主题时，文章封面图片可以设置，但文章内的图片无法显示，markdown 语法和 HTML 语法都无济于事。最后死马当活马医，将hexo-asset-image卸载了，重试，居然可以了。</p><br><h3 id="Record-2：图片存放问题"><a href="#Record-2：图片存放问题" class="headerlink" title="Record 2：图片存放问题"></a>Record 2：图片存放问题</h3><p>有两个文件夹可以存放：&#x2F;source&#x2F;img 和 &#x2F;public&#x2F;img，但图片不能放在后者中，因为 &#x2F;public 目录下的东西都是执行 hexo g 生成的（从 &#x2F;source 目录获取相关内容），若执行 hexo clean 就全部被删除了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
